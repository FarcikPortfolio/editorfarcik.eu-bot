// server.js ‚Äî editorfarcik.eu bot (Discord.js v14)

// ===== Z√ÅKLAD + KEEP-ALIVE (Render/UptimeRobot) =====
require("dotenv").config();
const express = require("express");
const app = express();
const port = process.env.PORT || 3000;

app.get("/", (_req, res) => res.status(200).send("‚úÖ editorfarcik.eu bot bƒõ≈æ√≠."));
app.listen(port, () => console.log(`üåê Webserver bƒõ≈æ√≠ na portu ${port}`));

// ===== DISCORD.JS =====
const {
  Client, GatewayIntentBits, Partials,
  REST, Routes,
  EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle,
  StringSelectMenuBuilder, ModalBuilder, TextInputBuilder, TextInputStyle,
  PermissionsBitField, ChannelType, time, userMention, roleMention
} = require("discord.js");

// ====== ID KONSTANTY ======
const COLOR = 0xff4f8b; // r≈Ø≈æov√°

// Kan√°ly
const MODLOG_CHANNEL_ID        = "1430647278741229840"; // logy moderace
const RULES_CHANNEL_ID         = "1429033865829290016"; // /pravidla c√≠l
const FAQ_CHANNEL_ID           = "1429485626864173227"; // /faq c√≠l
const TICKET_PANEL_CHANNEL_ID  = "1429485456667443220"; // kam pos√≠l√° !ticket-panel
const TICKET_CATEGORY_ID       = "1429032923469713510"; // bƒõ≈æn√© tickety (objedn√°vky)
const WELCOME_CHANNEL_ID       = "1429032923469713511"; // v√≠tej
const WARN_PRIVATE_CATEGORY_ID = "1430626033241030717"; // priv√°tn√≠ varov√°n√≠/appeal kategorie

// Role
const SUPPORT_ROLES = [
  "1429036050260426855",
  "1432327929244942356",
  "1430295218074419211",
];
const BONUS_ROLES = [ // 2x ≈°ance ve giveaway
  "1429473348513169651",
  "1429037670386106428"
];

// Emoji (custom reakce na pravidlech)
const RULES_REACT_EMOJI = "<:ano:1432781271100035203>";

// ENV
const GUILD_ID  = process.env.GUILD_ID;
const CLIENT_ID = process.env.CLIENT_ID;
const TOKEN     = process.env.TOKEN;

// ====== HELPERS ======
const pink = () => new EmbedBuilder().setColor(COLOR);
const hasSomeRole = (member, ids) => ids.some(id => member.roles.cache.has(id));

async function sendToModlog(guild, embed) {
  try {
    const ch = guild.channels.cache.get(MODLOG_CHANNEL_ID) || await guild.channels.fetch(MODLOG_CHANNEL_ID).catch(()=>null);
    if (ch) await ch.send({ embeds: [embed.setTimestamp()] });
  } catch {}
}

// Kompozitn√≠ duration: "1d 3h 25m"
function parseCompoundDuration(str) {
  if (!str) return null;
  let totalSec = 0;
  const re = /(\d+)\s*(d|h|m|s)/gi;
  let m;
  while ((m = re.exec(str)) !== null) {
    const n = Number(m[1]);
    const u = m[2].toLowerCase();
    if (u === "d") totalSec += n * 86400;
    else if (u === "h") totalSec += n * 3600;
    else if (u === "m") totalSec += n * 60;
    else if (u === "s") totalSec += n;
  }
  return totalSec > 0 ? totalSec * 1000 : null;
}
const fmtMs = (ms) => {
  let s = Math.floor(ms/1000);
  const d = Math.floor(s/86400); s -= d*86400;
  const h = Math.floor(s/3600);  s -= h*3600;
  const m = Math.floor(s/60);    s -= m*60;
  const parts = [];
  if (d) parts.push(`${d}d`);
  if (h) parts.push(`${h}h`);
  if (m) parts.push(`${m}m`);
  if (s) parts.push(`${s}s`);
  return parts.join(" ") || "0s";
};

// ====== CLIENT ======
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.DirectMessages,
    GatewayIntentBits.MessageContent
  ],
  partials: [Partials.Channel, Partials.Message, Partials.GuildMember, Partials.User],
});

// ====== REGISTRACE SLASH P≈ò√çKAZ≈Æ ======
const commands = [
  // Moderace (role-gate)
  {
    name: "ban",
    description: "Trval√Ω ban u≈æivatele",
    default_member_permissions: "0",
    options: [
      { name: "u≈æivatel", type: 6, description: "Koho zabanovat", required: true },
      { name: "d≈Øvod", type: 3, description: "D≈Øvod", required: false }
    ]
  },
  {
    name: "tempban",
    description: "Doƒçasn√Ω ban",
    default_member_permissions: "0",
    options: [
      { name: "u≈æivatel", type: 6, required: true, description: "Koho zabanovat" },
      { name: "doba", type: 3, required: true, description: "Nap≈ô. 1d 3h 25m / 2h / 30m" },
      { name: "d≈Øvod", type: 3, required: false, description: "D≈Øvod" }
    ]
  },
  {
    name: "kick",
    description: "Vyhozen√≠ u≈æivatele",
    default_member_permissions: "0",
    options: [
      { name: "u≈æivatel", type: 6, required: true, description: "Koho vyhodit" },
      { name: "d≈Øvod", type: 3, required: false, description: "D≈Øvod" }
    ]
  },
  {
    name: "mute",
    description: "Timeout (umlƒçen√≠) na dobu",
    default_member_permissions: "0",
    options: [
      { name: "u≈æivatel", type: 6, required: true, description: "Koho umlƒçet" },
      { name: "doba", type: 3, required: true, description: "Nap≈ô. 1d 3h 25m / 2h / 30m" },
      { name: "d≈Øvod", type: 3, required: false, description: "D≈Øvod" }
    ]
  },
  {
    name: "tempmute",
    description: "Alias pro mute (stejn√© chov√°n√≠)",
    default_member_permissions: "0",
    options: [
      { name: "u≈æivatel", type: 6, required: true, description: "Koho umlƒçet" },
      { name: "doba", type: 3, required: true, description: "Nap≈ô. 1d 3h 25m / 2h / 30m" },
      { name: "d≈Øvod", type: 3, required: false, description: "D≈Øvod" }
    ]
  },
  {
    name: "warn",
    description: "Upozornit u≈æivatele (DM + log)",
    default_member_permissions: "0",
    options: [
      { name: "u≈æivatel", type: 6, required: true, description: "Koho varovat" },
      { name: "d≈Øvod", type: 3, required: true, description: "D≈Øvod varov√°n√≠" }
    ]
  },
  // Report (vid√≠ v≈°ichni)
  {
    name: "report",
    description: "Nahl√°sit u≈æivatele (vid√≠ v≈°ichni)",
    options: [
      { name: "u≈æivatel", type: 6, required: true, description: "Koho hl√°s√≠≈°" },
      { name: "d≈Øvod", type: 3, required: true, description: "Co provedl" }
    ]
  },
  // Pravidla (role-gate)
  {
    name: "pravidla",
    description: "Po≈°le embed s pravidly serveru do urƒçen√©ho kan√°lu",
    default_member_permissions: "0"
  },
  // FAQ (role-gate)
  {
    name: "faq",
    description: "Po≈°le embed s ƒçasto kladen√Ωmi ot√°zkami do urƒçen√©ho kan√°lu",
    default_member_permissions: "0"
  },
  // Ticket (role-gate)
  {
    name: "ticket",
    description: "Spr√°va ticket≈Ø",
    default_member_permissions: "0",
    options: [{ type: 1, name: "create", description: "Otev≈ô√≠t ticket ruƒçnƒõ (pro support role)" }]
  },
  // Giveaway (role-gate)
  {
    name: "giveaway",
    description: "Spr√°va giveaway",
    default_member_permissions: "0",
    options: [{ type: 1, name: "create", description: "Vytvo≈ôit novou giveaway (modal)" }]
  },
];

async function registerSlash() {
  const rest = new REST({ version: "10" }).setToken(TOKEN);
  await rest.put(Routes.applicationGuildCommands(CLIENT_ID, GUILD_ID), { body: commands });
  console.log("‚úÖ Slash p≈ô√≠kazy registrov√°ny");
}

// ====== STAVY ======
const activeTickets = new Map(); // channelId -> userId
const runningGiveaways = new Map(); // messageId -> { entrants:Set, endsAt, winners, prize, channelId }

// ====== READY ======
client.once("ready", async () => {
  console.log(`‚úÖ ${client.user.tag} je online`);
  client.user.setActivity("üé¨ editorfarcik.eu", { type: 3 });
  try { await registerSlash(); } catch (e) { console.error("Slash registrace selhala:", e?.message || e); }
});

// ====== WELCOME ======
client.on("guildMemberAdd", async (m) => {
  const ch = m.guild.channels.cache.get(WELCOME_CHANNEL_ID) || await m.guild.channels.fetch(WELCOME_CHANNEL_ID).catch(()=>null);
  if (!ch) return;
  const e = pink()
    .setTitle("üëã V√≠tej na editorfarcik.eu")
    .setDescription(`${userMention(m.id)}, d√≠ky za p≈ôipojen√≠!\n\n‚Ä¢ Mrkni na **#pravidla** a dr≈æ se t√©matu.\n‚Ä¢ Pot≈ôebuje≈° edit? Ticket panel je v kan√°lu <#${TICKET_PANEL_CHANNEL_ID}>.\n‚Ä¢ M√°≈° dotaz? Vytvo≈ô si ticket.`)
    .setFooter({ text: "editorfarcik.eu | V√≠tej" });
  ch.send({ embeds: [e] }).catch(()=>{});
});

// ====== TEXT COMMANDS ======
client.on("messageCreate", async (msg) => {
  if (msg.author.bot || !msg.guild) return;

  // !ping
  if (msg.content.trim().toLowerCase() === "!ping") {
    const m = await msg.reply("üèì");
    const rtt = m.createdTimestamp - msg.createdTimestamp;
    return m.edit(`üèì Pong! ${rtt}ms`);
  }

  // !ticket-panel (jen admin)
  if (msg.content.trim().toLowerCase() === "!ticket-panel") {
    if (!msg.member.permissions.has(PermissionsBitField.Flags.Administrator)) return;
    const panelChannel = msg.guild.channels.cache.get(TICKET_PANEL_CHANNEL_ID) || await msg.guild.channels.fetch(TICKET_PANEL_CHANNEL_ID).catch(()=>null);
    if (!panelChannel) return msg.reply("‚ùå Kan√°l pro panel nenalezen.");

    const embed = pink()
      .setTitle("üì© Objedn√°vky")
      .setDescription("Vyber typ ticketu.\n\n‚ö†Ô∏è *Tento syst√©m je urƒçen pro objedn√°vky a dotazy ohlednƒõ edit≈Ø.*")
      .setFooter({ text: "editorfarcik.eu | Podpora ticketu" });

    const menu = new StringSelectMenuBuilder()
      .setCustomId("ticket_category")
      .setPlaceholder("üßæ Vyber typ ticketu")
      .addOptions(
        { label: "üé¨ Objedn√°vka editu", description: "Chci objednat edit.", value: "order" },
        { label: "ü§ù Spolupr√°ce", description: "M√°m z√°jem o spolupr√°ci.", value: "collab" },
        { label: "üí¨ Dotaz / poradenstv√≠", description: "Pot≈ôebuji poradit.", value: "question" },
      );

    await panelChannel.send({ embeds: [embed], components: [new ActionRowBuilder().addComponents(menu)] });
    if (msg.channel.id !== panelChannel.id) await msg.reply("‚úÖ Ticket panel byl odesl√°n.");
  }
});

// ====== SELECT -> MODAL (ticket panel) ======
client.on("interactionCreate", async (it) => {
  if (!it.isStringSelectMenu() || it.customId !== "ticket_category") return;
  const type = it.values[0];

  const modal = new ModalBuilder()
    .setCustomId(`ticket_form_${type}`)
    .setTitle("üé´ Nov√Ω ticket");

  const name    = new TextInputBuilder().setCustomId("name").setLabel("Tvoje jm√©no nebo p≈ôezd√≠vka").setStyle(TextInputStyle.Short).setRequired(true);
  const contact = new TextInputBuilder().setCustomId("contact").setLabel("Kontakt").setStyle(TextInputStyle.Short).setRequired(true);
  const details = new TextInputBuilder().setCustomId("details").setStyle(TextInputStyle.Paragraph).setRequired(true);

  if (type === "order")      details.setLabel("Popi≈°, co chce≈° upravit").setPlaceholder("Nap≈ô. cinematic edit s hudbou a efekty‚Ä¶");
  else if (type === "collab")details.setLabel("O jakou spolupr√°ci m√°≈° z√°jem?").setPlaceholder("Nap≈ô. dlouhodob√° spolupr√°ce na editech‚Ä¶");
  else                       details.setLabel("Popi≈°, o co jde").setPlaceholder("S ƒç√≠m pot≈ôebuje≈° poradit?");

  modal.addComponents(
    new ActionRowBuilder().addComponents(name),
    new ActionRowBuilder().addComponents(details),
    new ActionRowBuilder().addComponents(contact),
  );

  await it.showModal(modal);
});

// ====== MODAL SUBMIT -> CREATE TICKET ======
client.on("interactionCreate", async (it) => {
  if (!it.isModalSubmit() || !it.customId.startsWith("ticket_form_")) return;

  const type = it.customId.replace("ticket_form_", "");
  const guild = it.guild ?? (await client.guilds.fetch(GUILD_ID));
  const category = guild.channels.cache.get(TICKET_CATEGORY_ID) || await guild.channels.fetch(TICKET_CATEGORY_ID).catch(()=>null);
  if (!category) return it.reply({ content: "‚ùå Kategorie pro tickety nenalezena.", ephemeral: true });

  const name = it.fields.getTextInputValue("name");
  const contact = it.fields.getTextInputValue("contact");
  const details = it.fields.getTextInputValue("details");

  const map = {
    order:    { text: "Objedn√°vka editu", icon: "üé¨", slug: "objednavka" },
    collab:   { text: "Spolupr√°ce",       icon: "ü§ù", slug: "spoluprace" },
    question: { text: "Dotaz / poradenstv√≠", icon: "üí¨", slug: "dotaz" },
  };
  const t = map[type] || { text: "Ticket", icon: "üéüÔ∏è", slug: "ticket" };

  const ch = await guild.channels.create({
    name: `${t.icon}‚îÇ${t.slug}-${it.user.username}`.toLowerCase(),
    type: ChannelType.GuildText,
    parent: category.id,
    permissionOverwrites: [
      { id: guild.roles.everyone, deny: [PermissionsBitField.Flags.ViewChannel] },
      { id: it.user.id, allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages] },
      { id: client.user.id, allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages] },
      ...SUPPORT_ROLES.map(rid => ({ id: rid, allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages] })),
    ],
  });

  const emb = pink()
    .setTitle("üéüÔ∏è Nov√Ω ticket")
    .setDescription(`**Kategorie:** ${t.text}\n**U≈æivatel:** ${it.user}\n\n**Jm√©no:** ${name}\n**Kontakt:** ${contact}\n**Detail:** ${details}`)
    .setFooter({ text: "editorfarcik.eu | Podpora ticketu" });

  const row = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId("take_ticket").setStyle(ButtonStyle.Success).setLabel("‚úÖ P≈ôevz√≠t"),
    new ButtonBuilder().setCustomId("close_ticket").setStyle(ButtonStyle.Danger).setLabel("üîí Zav≈ô√≠t ticket"),
  );

  await ch.send({ content: `<@${it.user.id}>`, embeds: [emb], components: [row] });
  await it.reply({ content: `‚úÖ Ticket vytvo≈ôen: ${ch}`, ephemeral: true });
});

// ====== Ticket tlaƒç√≠tka ======
client.on("interactionCreate", async (it) => {
  if (!it.isButton()) return;

  if (it.customId === "take_ticket") {
    const can = hasSomeRole(it.member, SUPPORT_ROLES);
    if (!can) return it.reply({ content: "‚ùå Nem√°≈° opr√°vnƒõn√≠ p≈ôevz√≠t tento ticket.", ephemeral: true });

    const current = activeTickets.get(it.channel.id);
    if (current === it.user.id) {
      activeTickets.delete(it.channel.id);
      return it.reply({ content: `üö´ ${it.user} se vzdal ticketu.`, ephemeral: true });
    } else {
      activeTickets.set(it.channel.id, it.user.id);
      return it.reply({ content: `‚úÖ Ticket p≈ôevzal: ${it.user}`, ephemeral: true });
    }
  }

  if (it.customId === "close_ticket") {
    await it.reply({ content: "üîí Ticket se uzav≈ôe za 5 sekund‚Ä¶", ephemeral: true });
    setTimeout(() => it.channel.delete().catch(()=>{}), 5000);
  }
});

// ====== DM ‚Üí ‚ÄûKontaktovat podporu‚Äú tlaƒç√≠tko z /warn ======
client.on("interactionCreate", async (it) => {
  if (!it.isButton() || it.customId !== "open_support_from_warn") return;

  const guild = await client.guilds.fetch(GUILD_ID);
  const member = await guild.members.fetch(it.user.id).catch(()=>null);
  const category = guild.channels.cache.get(WARN_PRIVATE_CATEGORY_ID) || await guild.channels.fetch(WARN_PRIVATE_CATEGORY_ID).catch(()=>null);
  if (!member || !category) return it.reply({ content: "‚ùå Nelze vytvo≈ôit ticket.", ephemeral: true });

  const ch = await guild.channels.create({
    name: "‚îÇ„Éªüì©‚îÇpodpora",
    type: ChannelType.GuildText,
    parent: category.id,
    permissionOverwrites: [
      { id: guild.roles.everyone, deny: [PermissionsBitField.Flags.ViewChannel] },
      { id: it.user.id, allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages] },
      ...SUPPORT_ROLES.map(rid => ({ id: rid, allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages] })),
      { id: client.user.id, allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages] },
    ],
  });

  await ch.send({
    content: `<@${it.user.id}>`,
    embeds: [pink().setTitle("üì® Ticket z varov√°n√≠").setDescription("Napi≈° pros√≠m, co pot≈ôebuje≈° k varov√°n√≠ do≈ôe≈°it.").setFooter({ text: "editorfarcik.eu | Podpora ticketu" })]
  });

  await it.reply({ content: `‚úÖ Otev≈ôel jsem ticket: ${ch}`, ephemeral: true });
});

// ====== SLASH HANDLERY ======
client.on("interactionCreate", async (it) => {
  if (!it.isChatInputCommand()) return;

  const isSupportCmd = ["ban","tempban","kick","mute","tempmute","warn","ticket","giveaway","pravidla","faq"].includes(it.commandName);
  if (isSupportCmd && !hasSomeRole(it.member, SUPPORT_ROLES)) {
    return it.reply({ content: "‚ùå Nem√°≈° opr√°vnƒõn√≠ pro tento p≈ô√≠kaz.", ephemeral: true });
  }

  // ----- /pravidla (p≈ôesnƒõ text + auto reakce)
  if (it.commandName === "pravidla") {
    const ch = it.guild.channels.cache.get(RULES_CHANNEL_ID) || await it.guild.channels.fetch(RULES_CHANNEL_ID).catch(()=>null);
    if (!ch) return it.reply({ content: "‚ùå Kan√°l s pravidly nenalezen.", ephemeral: true });

    const e = pink()
      .setTitle("üìú Pravidla serveru editorfarcik.eu")
      .setDescription([
        "V√≠tej v **editorfarcik.eu!** Pros√≠m v≈°echny o dodr≈æov√°n√≠ v≈°ech tƒõchto pravidel.",
        "**Neznalost pravidel neomlouv√°!**",
        "",
        "I. üö´ **≈Ω√°dn√Ω spam nebo flood**",
        "‚Ä¢ Nepos√≠lej opakovanƒõ stejnou zpr√°vu nebo zbyteƒçn√© reakce/emotikony.",
        "",
        "II. üëë **≈Ω√°dn√© ur√°≈æky, rasismus nebo toxick√© chov√°n√≠**",
        "‚Ä¢ Buƒè respektuj√≠c√≠ v≈Øƒçi ostatn√≠m, ≈æ√°dn√Ω hate, homofobie ani ur√°≈æky.",
        "",
        "III. üì¢ **Z√°kaz reklamy a propagace**",
        "‚Ä¢ Ne≈°i≈ô sv√© servery, odkazy nebo soci√°ln√≠ s√≠tƒõ bez povolen√≠.",
        "",
        "IV. üõ° **Respektuj moder√°tory**",
        "‚Ä¢ Rozhodnut√≠ admin≈Ø a moder√°tor≈Ø jsou fin√°ln√≠. Nepokou≈°ej se je obej√≠t.",
        "",
        "V. ‚úÖ **Vhodn√Ω obsah**",
        "‚Ä¢ ≈Ω√°dn√Ω NSFW obsah, viry, exploity ani cokoliv neleg√°ln√≠ho.",
        "",
        "VI. üîí **Z√°kaz podvod≈Ø (scamov√°n√≠)**",
        "‚Ä¢ Jak√Ωkoliv pokus o podvod vede k okam≈æit√©mu banu.",
        "",
        "VII. üìè **Dodr≈æuj pravidla Discordu**",
        "‚Ä¢ Discord ToS ‚Ä¢ Pravidla komunity Discordu",
        "",
        "Poru≈°en√≠m pravidel riskuje≈° mute, kick nebo ban ‚Äì i bez p≈ôedchoz√≠ho varov√°n√≠."
      ].join("\n"))
      .setFooter({ text: "editorfarcik.eu | Pravidla serveru" });

    const sent = await ch.send({ embeds: [e] });
    await sent.react(RULES_REACT_EMOJI).catch(()=>{});
    return it.reply({ content: "‚úÖ Pravidla odesl√°na + p≈ôid√°na reakce.", ephemeral: true });
  }

  // ----- /faq (poslat do FAQ channelu)
  if (it.commandName === "faq") {
    const faqChannel = it.guild.channels.cache.get(FAQ_CHANNEL_ID) || await it.guild.channels.fetch(FAQ_CHANNEL_ID).catch(()=>null);
    if (!faqChannel) return it.reply({ content: "‚ùå FAQ kan√°l nenalezen.", ephemeral: true });

    const faqEmbed = pink()
      .setTitle("‚ùì ƒåasto kladen√© ot√°zky")
      .setDescription([
        "**Kolik st≈ôih videa stoj√≠?**",
        "Cena nen√≠ fixn√≠. Z√°le≈æ√≠ na d√©lce videa, stylu efekt≈Ø, n√°roƒçnosti a deadline. Po≈°le≈° uk√°zku videa + styl, ≈ôeknu cenu.",
        "",
        "**Jak dlouho st≈ôih videa zabere?**",
        "Standardnƒõ 1‚Äì7 dn√≠ podle n√°roƒçnosti. Rychlej≈°√≠ term√≠ny jdou, ale plat√≠ se p≈ô√≠platek. (z d≈Øvodu studov√°n√≠)",
        "",
        "**V jak√©m form√°tu odevzd√°v√°≈°?**",
        "MP4 (H.264/H.265), 1080p/4K podle domluvy. V≈°e optimalizovan√© pro platformu.",
        "",
        "**Dƒõl√°≈° i thumbnaily/miniatury?**",
        "Ano, ale je to extra polo≈æka za men≈°√≠ p≈ô√≠platek.",
        "",
        "**Zp≈Øsob platby?**",
        "P≈ôevodem na bankovn√≠ √∫ƒçet.",
        "",
        "**Co kdy≈æ se mi to nel√≠b√≠?**",
        "≈òekne≈° mi p≈ôesnƒõ co se ti nel√≠b√≠ a j√° to uprav√≠m podle tv√Ωch p≈ôedstav."
      ].join("\n"))
      .setFooter({ text: "editorfarcik.eu | FAQ" });

    await faqChannel.send({ embeds: [faqEmbed] });
    return it.reply({ content: "‚úÖ FAQ odesl√°no do urƒçen√©ho kan√°lu.", ephemeral: true });
  }

  // ----- /report (vid√≠ v≈°ichni, log do modlogu)
  if (it.commandName === "report") {
    const user = it.options.getUser("u≈æivatel", true);
    const reason = it.options.getString("d≈Øvod", true);
    const emb = pink()
      .setTitle("üö® Report")
      .setDescription(`**Nahl√°sil:** ${it.user}\n**Nahl√°≈°en√Ω:** ${user}\n**D≈Øvod:** ${reason}\n**ƒåas:** ${time(Math.floor(Date.now()/1000))}`)
      .setFooter({ text: "editorfarcik.eu | Moderace syst√©mu" });
    await sendToModlog(it.guild, emb);
    return it.reply({ content: "‚úÖ D√≠ky, nahl√°≈°en√≠ jsme p≈ôijali.", ephemeral: true });
  }

  // ----- Moderace (role-gate v√Ω≈°e)
  if (it.commandName === "warn") {
    const user = it.options.getUser("u≈æivatel", true);
    const reason = it.options.getString("d≈Øvod", true);

    // DM warn + tlaƒç√≠tko
    try {
      const dmEmbed = pink()
        .setTitle("‚ö†Ô∏è Varov√°n√≠")
        .setDescription(`Byl jsi varov√°n na serveru **editorfarcik.eu**.\n**D≈Øvod:** ${reason}`)
        .setFooter({ text: "editorfarcik.eu | Podpora varov√°n√≠" });
      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId("open_support_from_warn").setStyle(ButtonStyle.Primary).setLabel("üì© Kontaktovat podporu")
      );
      const u = await client.users.fetch(user.id);
      await u.send({ embeds: [dmEmbed], components: [row] }).catch(()=>{});
    } catch {}

    const log = pink().setTitle("‚ö†Ô∏è Varov√°n√≠ udƒõleno")
      .setDescription(`**Moder√°tor:** ${it.user}\n**U≈æivatel:** ${user}\n**D≈Øvod:** ${reason}`)
      .setFooter({ text: "editorfarcik.eu | Moderace syst√©mu" });
    await sendToModlog(it.guild, log);
    return it.reply({ content: "‚úÖ Upozornƒõn√≠ odesl√°no a zalogov√°no.", ephemeral: true });
  }

  if (it.commandName === "ban") {
    const user = it.options.getUser("u≈æivatel", true);
    const reason = it.options.getString("d≈Øvod") || "Neuvedeno";
    const member = await it.guild.members.fetch(user.id).catch(()=>null);
    if (!member) return it.reply({ content: "‚ùå U≈æivatel nen√≠ na serveru.", ephemeral: true });
    await member.ban({ reason }).catch(e=> it.reply({ content: `‚ùå Nepovedlo se: ${e?.message||e}`, ephemeral:true }));
    await sendToModlog(it.guild, pink().setTitle("üî® Ban").setDescription(`**Moder√°tor:** ${it.user}\n**U≈æivatel:** ${user}\n**D≈Øvod:** ${reason}`).setFooter({ text:"editorfarcik.eu | Moderace syst√©mu" }));
    return it.reply({ content: "‚úÖ Zabanov√°n.", ephemeral: true });
  }

  if (it.commandName === "tempban") {
    const user = it.options.getUser("u≈æivatel", true);
    const reason = it.options.getString("d≈Øvod") || "Neuvedeno";
    const durStr = it.options.getString("doba", true);
    const ms = parseCompoundDuration(durStr);
    if (!ms) return it.reply({ content: "‚ùå ≈†patn√Ω form√°t doby. Pou≈æij nap≈ô. `1d 3h 25m`, `2h`, `30m`.", ephemeral: true });

    const member = await it.guild.members.fetch(user.id).catch(()=>null);
    if (!member) return it.reply({ content: "‚ùå U≈æivatel nen√≠ na serveru.", ephemeral: true });
    await member.ban({ reason }).catch(e=> it.reply({ content: `‚ùå Nepovedlo se: ${e?.message||e}`, ephemeral:true }));

    setTimeout(async () => {
      await it.guild.members.unban(user.id, "Vypr≈°el tempban").catch(()=>{});
    }, ms);

    await sendToModlog(it.guild, pink().setTitle("‚è≥ Tempban").setDescription(`**Moder√°tor:** ${it.user}\n**U≈æivatel:** ${user}\n**Doba:** ${fmtMs(ms)}\n**D≈Øvod:** ${reason}`).setFooter({ text:"editorfarcik.eu | Moderace syst√©mu" }));
    return it.reply({ content: "‚úÖ Doƒçasn√Ω ban udƒõlen.", ephemeral: true });
  }

  if (it.commandName === "kick") {
    const user = it.options.getUser("u≈æivatel", true);
    const reason = it.options.getString("d≈Øvod") || "Neuvedeno";
    const member = await it.guild.members.fetch(user.id).catch(()=>null);
    if (!member) return it.reply({ content: "‚ùå U≈æivatel nen√≠ na serveru.", ephemeral: true });
    await member.kick(reason).catch(e=> it.reply({ content: `‚ùå Nepovedlo se: ${e?.message||e}`, ephemeral:true }));
    await sendToModlog(it.guild, pink().setTitle("ü•æ Kick").setDescription(`**Moder√°tor:** ${it.user}\n**U≈æivatel:** ${user}\n**D≈Øvod:** ${reason}`).setFooter({ text:"editorfarcik.eu | Moderace syst√©mu" }));
    return it.reply({ content: "‚úÖ Vyhozen.", ephemeral: true });
  }

  if (it.commandName === "mute" || it.commandName === "tempmute") {
    const user = it.options.getUser("u≈æivatel", true);
    const reason = it.options.getString("d≈Øvod") || "Neuvedeno";
    const durStr = it.options.getString("doba", true);
    const ms = parseCompoundDuration(durStr);
    if (!ms) return it.reply({ content: "‚ùå ≈†patn√Ω form√°t doby. Pou≈æij `1d 3h 25m` / `2h` / `30m`‚Ä¶", ephemeral: true });

    const member = await it.guild.members.fetch(user.id).catch(()=>null);
    if (!member) return it.reply({ content: "‚ùå U≈æivatel nen√≠ na serveru.", ephemeral: true });
    await member.timeout(ms, reason).catch(e=> it.reply({ content: `‚ùå Nepovedlo se: ${e?.message||e}`, ephemeral:true }));

    await sendToModlog(it.guild, pink().setTitle("üîá Timeout").setDescription(`**Moder√°tor:** ${it.user}\n**U≈æivatel:** ${user}\n**Doba:** ${fmtMs(ms)}\n**D≈Øvod:** ${reason}`).setFooter({ text:"editorfarcik.eu | Moderace syst√©mu" }));
    return it.reply({ content: "‚úÖ Timeout nastaven.", ephemeral: true });
  }

  // ----- /ticket create
  if (it.commandName === "ticket" && it.options.getSubcommand() === "create") {
    const category = it.guild.channels.cache.get(TICKET_CATEGORY_ID) || await it.guild.channels.fetch(TICKET_CATEGORY_ID).catch(()=>null);
    if (!category) return it.reply({ content: "‚ùå Kategorie nenalezena.", ephemeral: true });

    const ch = await it.guild.channels.create({
      name: `üéü‚îÇticket-${it.user.username}`.toLowerCase(),
      type: ChannelType.GuildText,
      parent: category.id,
      permissionOverwrites: [
        { id: it.guild.roles.everyone, deny: [PermissionsBitField.Flags.ViewChannel] },
        { id: it.user.id, allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages] },
        ...SUPPORT_ROLES.map(rid => ({ id: rid, allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages] })),
      ],
    });
    await ch.send({ embeds: [pink().setTitle("üéüÔ∏è Ticket vytvo≈ôen").setDescription(`Ticket otev≈ôel ${it.user}`).setFooter({ text:"editorfarcik.eu | Podpora ticketu" })] });
    return it.reply({ content: `‚úÖ Ticket: ${ch}`, ephemeral: true });
  }

  // ----- /giveaway create (modal)
  if (it.commandName === "giveaway" && it.options.getSubcommand() === "create") {
    const modal = new ModalBuilder().setCustomId("gw_create_modal").setTitle("üéâ Vytvo≈ôit giveaway");
    const prize    = new TextInputBuilder().setCustomId("gw_prize").setLabel("Co se vyhr√°v√°?").setRequired(true).setStyle(TextInputStyle.Short);
    const winners  = new TextInputBuilder().setCustomId("gw_winners").setLabel("Poƒçet v√Ωherc≈Ø").setRequired(true).setStyle(TextInputStyle.Short).setPlaceholder("nap≈ô. 1");
    const duration = new TextInputBuilder().setCustomId("gw_duration").setLabel("Doba trv√°n√≠").setRequired(true).setStyle(TextInputStyle.Short).setPlaceholder("nap≈ô. 1d 3h 25m / 2h / 30m");

    modal.addComponents(
      new ActionRowBuilder().addComponents(prize),
      new ActionRowBuilder().addComponents(winners),
      new ActionRowBuilder().addComponents(duration),
    );
    return it.showModal(modal);
  }
});

// ====== Giveaway modal -> vytvo≈ôen√≠
client.on("interactionCreate", async (it) => {
  if (!it.isModalSubmit() || it.customId !== "gw_create_modal") return;

  const prize = it.fields.getTextInputValue("gw_prize");
  const winnersCount = Math.max(1, parseInt(it.fields.getTextInputValue("gw_winners") || "1", 10));
  const durStr = it.fields.getTextInputValue("gw_duration");
  const ms = parseCompoundDuration(durStr);
  if (!ms) return it.reply({ content: "‚ùå ≈†patn√Ω form√°t doby. Pou≈æij `1d 3h 25m`, `2h`, `30m`‚Ä¶", ephemeral: true });

  const ends = Date.now() + ms;
  const joinBtn = new ButtonBuilder().setCustomId("gw_join").setLabel("üéâ P≈ôihl√°sit se").setStyle(ButtonStyle.Success);
  const e = pink()
    .setTitle("üéâ Giveaway")
    .setDescription([
      `**Cena:** ${prize}`,
      `**Poƒçet v√Ωherc≈Ø:** ${winnersCount}`,
      `**Konƒç√≠:** ${time(Math.floor(ends/1000), "R")}`,
      `üë• **Poƒçet √∫ƒçastn√≠k≈Ø:** 0`,
      `\nRole s vƒõt≈°√≠ ≈°anc√≠: ${BONUS_ROLES.map(roleMention).join(", ")} (2√ó)`,
    ].join("\n"))
    .setFooter({ text: "editorfarcik.eu | Giveaway" });

  const msg = await it.channel.send({ embeds: [e], components: [new ActionRowBuilder().addComponents(joinBtn)] });
  runningGiveaways.set(msg.id, { entrants: new Set(), endsAt: ends, winners: winnersCount, prize, channelId: msg.channel.id });

  setTimeout(async () => {
    const gw = runningGiveaways.get(msg.id);
    if (!gw) return;

    const entries = [...gw.entrants];
    if (!entries.length) {
      await msg.reply({ embeds: [pink().setTitle("üéâ Giveaway").setDescription("Nikdo se nep≈ôihl√°sil.").setFooter({ text:"editorfarcik.eu | Giveaway" })] });
      runningGiveaways.delete(msg.id);
      return;
    }

    const guild = await client.guilds.fetch(GUILD_ID);
    const weighted = [];
    for (const id of entries) {
      const m = await guild.members.fetch(id).catch(()=>null);
      if (!m) continue;
      weighted.push(id);
      if (hasSomeRole(m, BONUS_ROLES)) weighted.push(id); // 2√ó ≈°ance
    }

    const winners = [];
    while (winners.length < gw.winners && weighted.length) {
      const pick = weighted[Math.floor(Math.random()*weighted.length)];
      if (!winners.includes(pick)) winners.push(pick);
    }

    const wText = winners.length ? winners.map(userMention).join(", ") : "nikdo";
    await msg.reply({ embeds: [pink().setTitle("ü•≥ V√Ωherci").setDescription(`**V√Ωhra:** ${gw.prize}\n**V√Ωherci:** ${wText}`).setFooter({ text:"editorfarcik.eu | Giveaway" })] });
    runningGiveaways.delete(msg.id);
  }, ms);

  return it.reply({ content: "‚úÖ Giveaway zalo≈æena.", ephemeral: true });
});

// klik na ‚ÄûP≈ôihl√°sit se‚Äú
client.on("interactionCreate", async (it) => {
  if (!it.isButton() || it.customId !== "gw_join") return;
  const gw = runningGiveaways.get(it.message.id);
  if (!gw) return it.reply({ content: "‚ùå Tahle giveaway u≈æ neexistuje.", ephemeral: true });

  if (gw.entrants.has(it.user.id)) {
    return it.reply({ content: "‚ö†Ô∏è U≈æ jsi p≈ôihl√°≈°en do t√©to giveaway.", ephemeral: true });
  }
  gw.entrants.add(it.user.id);

  // aktualizuj poƒçet √∫ƒçastn√≠k≈Ø v embedu
  const old = it.message.embeds?.[0];
  if (old) {
    const emb = EmbedBuilder.from(old);
    const desc = emb.data.description || "";
    const updated = desc.replace(/Poƒçet √∫ƒçastn√≠k≈Ø:\s*\d+/i, `Poƒçet √∫ƒçastn√≠k≈Ø: ${gw.entrants.size}`);
    emb.setDescription(updated);
    await it.message.edit({ embeds: [emb] }).catch(()=>{});
  }

  return it.reply({ content: "üéâ Byl jsi √∫spƒõ≈°nƒõ p≈ôihl√°≈°en do giveaway!", ephemeral: true });
});

// ====== START ======
client.login(TOKEN);
